Respostas dos exerc√≠cios de teoria do livro: Caelum
2.16 Por que Java foi escolhido em um projeto?
Geralmente java √© escolhido pela portabilidade pois roda em qualquer sistema que tenha JVM, ou seja √© ideal pra projetos que precisam rodar em Windows, Linux, mac ou at√© em servidores diferentes. 
Java tamb√©m apresenta um diversidade grande de bibliotecas, pra web, banco de dados, seguran√ßa.
√â bem r√°pido JIT compilation e tem uma boa gest√£o de memoria gra√ßas ao garbage collector.
Java √© fortemente tipado o que ajuda a evitar erros.
Projetos grandes se beneficiam da estrutura de pacotes, modularidade e orienta√ß√£o a objetos.
Java possui diversos frameworks e ferramentas como Spring, Hibernate, Maven, Grandle, que facilitam o desenvolvimento...
Em resumo: O Java geralmente √© escolhido quando se precisa de portabilidade, seguran√ßa, estabilidade e grande suporte da comunidade.

1) Um arquivo fonte java sempre deve terminar com .java Exemplo: MinhaClasse.java
Se a classe for public, o nome do arquivo deve ser igual ao nome da classe.

Compila√ß√£o e execu√ß√£o:
Compile: javac OutraClasse.java
Isso gera OutraClasse.class(bytecode)
Execute: java OutraClasse (N√£o coloque .class)

3.3 Exercicios: (Realizados)

3.4 Conven√ß√µes de c√≥digo e c√≥digo leg√≠-
vel

Conven√ß√µes de c√≥digo, Por que existem? 
1. Padroniza√ß√£o: Permitem que desenvolvedores escrevam c√≥digos de forma consistente.
2. Facilitam a leitura e manuten√ß√£o: C√≥digo padronizado √© mais f√°cil de entender para outros desenvolvedores, mesmo que nunca tenham visto o projeto antes.
3. Reduz erros: Seguir padr√µes ajuda a evitar confus√µes e problemas, principalmente  em projetos grandes com v√°rias pessoas

Por que s√£o importantes?
Mantem a consist√™ncia e evita bugs e retrabalho.
IDE's, linters e frameworks funcionam melhor quando voc√™ segue conven√ß√µes.
Facilita o onboarding de novos desenvolvedores.

(Linter): √© uma ferramenta que analisa seu c√≥digo para encontrar problemas de estilo, erros comuns ou m√°s praticas. Exemplo Checkstyle √© um linter que verifica se voc√™ est√° seguindo as conven√ß√µes Java (nomes de m√©todos,identa√ß√£o,etc.).

(Onboarding): √© o processo de integra√ß√£o de um novo funcion√°rio ou desenvolvedor em uma equipe ou projeto. Inclui: aprender sobre o c√≥digo, ferramentas, processos e  cultura da empresa.
Quanto mais leg√≠vel e padronizado for o c√≥digo, mais f√°cil e r√°pido √© o onboarding.


As vantagens de escrever um c√≥digo limpo e f√°cil de ler s√£o a redu√ß√£o de erros, manuten√ß√£o mais simples e menos necessidade de coment√°rios.



3.12

1) do-while: quando queremos que a tarefa seja executada ao menos uma vez.
switch: √© interessante quando temos uma cadeia de valores fixos, o que √© mais interessante do que diversos else if.

2) Geralmente em um c√≥digo bem limpo n√£o teremos labeled loops. Mas ele √© usado em for aninhados permitindo dar nome a um la√ßo e usar break; ou continue  para interromper ou pular um la√ßo externo.

3) Numero inteiro dividido por 0 -> Lan√ßa ArithmeticException que √© um erro.
Numero ponto flutuante dividido por 0.0 -> N√£o lan√ßa erro, retorna infinity ou -infinity dependendo do sinal.

4) Casting entre tipos primitivos
H√° uma convers√£o autom√°tica chamada widening de tipos menores para maiores
byte -> short -> int -> long -> float -> double
char -> int -> long -> float -> double

O casting explicido √© necess√°rio quando vai de um tipo maior para menor, para evitar perda de dados.


5) Incremento ou decremento e opera√ß√µes compostas.
Incremento: i++ (p√≥s), ++i (pr√©) ‚Üí soma 1 ao valor de i
Decremento: i-- ou --i ‚Üí subtrai 1 do valor de i
Operadores compostos: i += x ‚Üí i = i + x, i -= x ‚Üí i = i - x

3.13/ 3.14 Exerc√≠cios de fixa√ß√£o de sintaxe (pulados).

4.11 Exercicios

1) N√£o pode come√ßar com n√∫mero (ex.: 1nome ‚Üí errado)

Pode usar letras, n√∫meros, $ e _, mas n√£o espa√ßos ou s√≠mbolos especiais.

Nomes sens√≠veis a mai√∫sculas/min√∫sculas (idade ‚â† Idade)

Palavras reservadas do Java n√£o podem ser usadas (class, int, for, etc.)

2) Vari√°veis e  m√©todos:  camelCase ‚Üí come√ßa com letra min√∫scula, depois mai√∫sculas em palavras internas (nomeFuncionario)

Classes:  PascalCase ‚Üí todas palavras iniciam com mai√∫scula (Funcionario)

Constantes:  UPPER_CASE (PI)

Objetivo:  facilitar leitura, manuten√ß√£o e entendimento do c√≥digo entre programadores.

3) N√£o √© obrigat√≥ria se n√£o houver ambiguidade entre atributos e par√¢metros.

4) √â uma linguagem padr√£o de diagramas para modelar sistemas orientados a objetos.

Usos principais:

Representar classes, atributos, m√©todos, relacionamentos e fluxos do sistema.

Facilita comunica√ß√£o, planejamento e documenta√ß√£o.

Ex.: Diagrama de classes UML de um Funcionario mostra atributos (nome, salario) e m√©todos (getNome(), setSalario()).

4.12 Exerc√≠cios: Orienta√ß√£o a Objetos (Realizados)

4.13 (Pendente)
Realizar exerc√≠cio pra resolver a s√©rie de Fibonacci com recursividade.

4.14 (Pulados)


6.7 Um pouco mais...
1) Em algumas empresas, o UML √© amplamente utilizado. √Äs vezes, o programador recebe o UML j√° pronto,
completo, e s√≥ deve preencher a implementa√ß√£o, devendo seguir √† risca o UML. O que voc√™ acha dessa
pr√°tica? Quais as vantagens e desvantagens.
Entre as vantagens temos, a visualiza√ß√£o, porque o UML ajuda a entender melhor o sistema antes de come√ßar a codar, a padroniza√ß√£o, pois o UML √© uma linguagem padronizada para modelagem de sistemas, Documenta√ß√£o pois o uml funciona como documento do sistema, para o planejamento e design pois auxilia na identifica√ß√£o das classes, objetos e relacionamentos e reduz erros e retrabalho. E pode ser usado em sistemas pequenos e grandes e diferentes metodologias √°gil,cascata, iterativa

Desvantagens: para sistemas pequenos o uml pode ser um exagero e consumir tempo.
Nem todo mundo entende todos os tipos de diagramas(caso de uso,classe,sequencia,etc..) sem treinamento.
Manuten√ß√£o: podem ficar desatualizados se n√£o forem mantidos juntos com o c√≥digo.
Ferramentas: algumas ferramentas uml s√£o pagas ou complicadas de utilizar.
Formalidade: focar demais em diagramas pode atrasar a entrega do software, principalmente em equipes √°geis.

2) Se uma classe s√≥ tem atributos e m√©todos est√°ticos, que conclus√µes podemos tirar? O que lhe parece um
m√©todo est√°tico em casos como esses?
N√£o precisa de instancias ou seja como o Math em java, chamamos Math.sqrt(25), sem necessariamente criar um  Math m = new Math();
Geralmente essas classes possuem fun√ß√µes utilit√°rias ou constantes, como Converter.celsiusParaFahrenheit(), c√°lculos matem√°ticos, manipula√ß√µes de String etc...
Estado global: ou seja eles s√£o compartilhados com todos "Usu√°rios" da classe, isso √© como uma vari√°vel global, ent√£o precisamos ter cuidado com a concorr√™ncia ou efeitos colaterais.



3) No caso de atributos booleanos, pode-se usar no lugar do get o suxo is. Dessa maneira, caso tiv√©ssemos
um atributo booleano ligado, em vez de getLigado poder√≠amos ter isLigado.

Sim, isso √© uma conven√ß√£o da nomenclatura em Java para atributos booleanos.


======================================================================

6.8 Exercicios 
1) Com modificador de acesso em private n√£o √© possivel acessar os atributos diretamente, ou seja ficam encapsulados.
6) Seria interresante ter os dois, tanto para listar todos os funcionarios como para listar um determinado funcionario.
7) Se dermos um new Empresa() sem passar argumento algum d√° erro, pois √© necessario que tenha o tamanho do array caso coloque.
8) o int x est√° fora do escopo de uma instancia static, metodos static n√£o tem acesso a esses atributos da classe teste, a n√£o ser se instanciar o objeto teste
com Teste teste = new Teste(); ai sim conseguiria.
9) H√° dois passos para realiza√ß√£o do singleton, 
1. tornar o construtor privado para que n√£o tenha como criar um novo.
2. criar um m√©todo de cria√ß√£o est√°tico que atue como um construtor. 
Internamente, esse m√©todo chama o construtor privado para criar um objeto e salv√°-lo em um campo est√°tico. 
Todas as chamadas subsequentes a esse m√©todo retornam o objeto armazenado em cache.
Como fazer? 
1. Adicione um campo est√°tico privado √† classe para armazenar a inst√¢ncia singleton.

2.Declare um m√©todo de cria√ß√£o est√°tico p√∫blico para obter a inst√¢ncia singleton.

3.Implemente a "inicializa√ß√£o pregui√ßosa" dentro do m√©todo est√°tico. Ele deve criar um novo objeto na primeira chamada e coloc√°-lo no campo est√°tico. O m√©todo deve sempre retornar essa inst√¢ncia em todas as chamadas subsequentes.

4.Torne o construtor da classe privado. O m√©todo est√°tico da classe ainda poder√° chamar o construtor, mas n√£o os outros objetos.

5.Revise o c√≥digo do cliente e substitua todas as chamadas diretas ao construtor do singleton por chamadas ao seu m√©todo de cria√ß√£o est√°tico.

E para carater de aprendizado singleton 

package refactoring_guru.singleton.example.non_thread_safe;

Um breve exemplo:

public final class Singleton {
    private static Singleton instance;
    public String value;

    private Singleton(String value) {
        // The following code emulates slow initialization.
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        this.value = value;
    }

    public static Singleton getInstance(String value) {
        if (instance == null) {
            instance = new Singleton(value);
        }
        return instance;
    }
}

package refactoring_guru.singleton.example.non_thread_safe;

public class DemoSingleThread {
    public static void main(String[] args) {
        System.out.println("If you see the same value, then singleton was reused (yay!)" + "\n" +
                "If you see different values, then 2 singletons were created (booo!!)" + "\n\n" +
                "RESULT:" + "\n");
        Singleton singleton = Singleton.getInstance("FOO");
        Singleton anotherSingleton = Singleton.getInstance("BAR");
        System.out.println(singleton.value);
        System.out.println(anotherSingleton.value);
    }
}

//Informa√ß√£o retiradas do refactoring.guru

==============================================================

7.6
1) Se n√£o houvesse heran√ßa em Java, como voc√™ poderia reaproveitar o c√≥digo de outra classe? 
R: Acredito que no famoso crtl + c / ctrl + v/ Ou composi√ß√£o ou delega√ß√£o.

Composi√ß√£o: em vez de herdar de uma classe, voc√™ cria um atributo do tipo dessa classe e utiliza seus m√©todos.


2) Uma discuss√£o muito atual √© sobre o abuso no uso da heran√ßa. Algumas pessoas usam heran√ßa apenas
para reaproveitar o c√≥digo, quando poderiam ter feito uma composi√ß√£o. Procure sobre heran√ßa versus
composi√ß√£o.  

Heran√ßa vs Composi√ß√£o (discuss√£o atual):

Heran√ßa (is-a): usada quando a classe √© um tipo da outra. Ex: Cachorro extends Animal.

Vantagens: facilita polimorfismo, reaproveita c√≥digo.

Desvantagens: pode gerar acoplamento r√≠gido (mudan√ßas na classe m√£e afetam as filhas).

Composi√ß√£o (has-a): usada quando a classe possui um objeto de outra classe. Ex: Carro tem um Motor.

Vantagens: mais flex√≠vel, permite trocar implementa√ß√µes em tempo de execu√ß√£o, reduz acoplamento.

Desvantagens: √†s vezes gera mais "trabalho" na hora de repassar m√©todos.

Use heran√ßa quando h√° uma clara rela√ß√£o "√© um" (ex: Gato √© um Animal).

Prefira composi√ß√£o quando for apenas "tem um" (ex: Carro tem um Motor).


3) √â o uso de super() dentro dos construtores, que chama o construtor da classe m√£e.

====

7.7 Exerc√≠cios Heran√ßa e Poliformismo

4) Cada uma imprime um valor diferente, pois seus metodos foram reescritos.

5) Compila, pois o JVM decide em tempo de execu√ß√£o qual metodo  chamar, com poliformismo dinamico. √â util para generalizar o codigo  sem  precisar criar uma logica separada para cada subtipo

9) N√£o

10) Foi feito mas com arrayList

7.8) Usar protected em atributos afrouxa o encapsulamento ‚Üí n√£o √© a melhor pr√°tica.

O ideal √© manter os atributos sempre private.

Para as filhas trabalharem com eles, voc√™ pode:

Criar getters/setters protected.

Criar m√©todos espec√≠ficos protected (ex: saca(), deposita()) em vez de dar acesso livre.

Usar construtores protegidos para inicializar o atributo.

Assim, a heran√ßa funciona sem expor desnecessariamente os dados.

Resumindo: encapsulamento continua com private, e as filhas acessam via m√©todos controlados.

=======================================================
Capitulo 8 - Aborda mais sobre o eclipse IDE ent√£o foi pulado.
=======================================================

9.6 Classes Abstratas

1) Sim, pois n√£o queremos que uma conta seja s√≥ uma Conta e sim uma ContaCorrente ou ContaPoupan√ßa, ent√£o interface √© uma boa.

2) A vantagem √© generalizar e trabalhar com poliformismo dinamico.

3) A classe poupan√ßa √© obrigada a implementar pois na interface n√£o existe implementa√ß√£o

5) existe sim, mas a classe ContaCorrente tamb√©m teria que ser uma interface.

6) O metodo atualiza na classe √© pra firmar um contrato com quem extends essa abstract e ser obrigado, se apagarmos da classe Conta n√£o vamos poder referenciar.

7) ok

=====================================================
Os capitulos anteriores foram sobre classe abstrata e interface: Fazendo um comparativo direto entre os dois temos as seguintes caracteristicas. 
Uma classe abstrata √© usada quando existe algo em comum entre as classes, funcionando de forma parecida com a heran√ßa. Ela n√£o pode ser instanciada, pode ter atributos, m√©todos concretos e tamb√©m m√©todos abstratos. Normalmente √© usada quando se quer compartilhar estado e parte da implementa√ß√£o entre subclasses. S√≥ permite heran√ßa simples.

J√° a interface representa um contrato: qualquer classe que a implemente deve obrigatoriamente fornecer a implementa√ß√£o dos m√©todos definidos. Diferente da classe abstrata, quem implementa a interface n√£o precisa ter nada em comum al√©m da capacidade de realizar as a√ß√µes especificadas. Interfaces n√£o possuem atributos de inst√¢ncia, apenas constantes, e permitem m√∫ltiplas implementa√ß√µes, ou seja, uma classe pode implementar v√°rias interfaces ao mesmo tempo.

Usa classe abstrata quando as classes t√™m caracter√≠sticas em comum (atributos e parte da l√≥gica compartilhada) e tu quer reaproveitar c√≥digo.

Usa interface quando tu precisa s√≥ de um contrato de comportamento, sem heran√ßa de atributos ou implementa√ß√£o, e quando uma classe pode ter v√°rias "capacidades" diferentes ao mesmo tempo.

Exerc√≠cios dos capitulos anteriores feitos.

=======================================================
Cap 11. Exce√ß√µes e controle.
Exerc√≠cios resolvidos.

11.12) Quando a JVM (Java Virtual Machine) n√£o consegue mais alocar mem√≥ria para novos objetos, ela lan√ßa um java.lang.OutOfMemoryError.

‚ÄúHeap space‚Äù √© a √°rea de mem√≥ria onde os objetos do Java s√£o alocados.

Isso normalmente acontece quando:

Criamos muitos objetos e n√£o liberamos refer√™ncia a eles (vazamento de mem√≥ria / memory leak).

Alocamos arrays enormes ou cole√ß√µes gigantes.

üí° Observa√ß√£o: a JVM tenta primeiro liberar mem√≥ria via garbage collector (GC), mas se mesmo assim n√£o houver espa√ßo suficiente, o OutOfMemoryError ocorre.


=========================================================

Usar catch(Exception e) ou throws Exception √© m√° pr√°tica, porque generaliza os erros. Quem recebe a exce√ß√£o n√£o sabe exatamente qual tipo ocorreu e n√£o consegue trat√°-la corretamente.

Se queremos tratar v√°rias exce√ß√µes de forma igual (ex.: IOException e SQLException), n√£o √© recomend√°vel usar catch(Exception e), pois isso tamb√©m pegaria outras exce√ß√µes inesperadas.

A solu√ß√£o correta √© usar multi-catch (Java 7+), permitindo tratar m√∫ltiplas exce√ß√µes espec√≠ficas em um √∫nico bloco, sem duplicar c√≥digo:

try {
    // c√≥digo que pode lan√ßar IOException ou SQLException
} catch (IOException | SQLException e) {
    // tratamento comum para essas exce√ß√µes
}


‚úÖ Vantagem: mant√©m o tratamento espec√≠fico das exce√ß√µes sem generalizar para todas e evita repeti√ß√£o de c√≥digo.


====================================================================

Cap√≠tulo 14 - O pacote java.lang
Exerc√≠cios Realizados.

15)  (opcional) Pesquise a classe StringBuilder (ou StringBuer no Java 1.4). Ela √© mut√°vel. Por que us√°-la
em vez da String? Quando us√°-la? 

String √© imut√°vel, ent√£o cada concatena√ß√£o cria um novo objeto na mem√≥ria. 

StringBuilder √© mut√°vel, permitindo modificar a mesma sequ√™ncia de caracteres sem criar novos objetos.

Use String para poucas concatena√ß√µes e StringBuilder quando for fazer muitas altera√ß√µes ou dentro de loops, pois √© mais r√°pido e eficiente.

=====================================================================

Capitulo 15 java.io

Unicode e character encoding?


=====================================================================

Capitulo 16 Collections

compareTo(Object). Este m√©todo deve retornar zero, se o objeto comparado for igual a este objeto, um n√∫mero negativo, se este objeto for menor que o objeto dado, e um n√∫mero positivo, se este objeto for maior que o objeto dado.

Exerc√≠cios:

1) No ArrayList, a opera√ß√£o contains() percorre a lista elemento por elemento at√© encontrar (ou n√£o) o valor, ou seja, tem complexidade O(n). Isso torna a busca lenta quando o n√∫mero de elementos cresce, mesmo que a inser√ß√£o seja r√°pida.

J√° no HashSet, os elementos s√£o armazenados em uma tabela hash, o que faz com que a busca (contains()) seja feita em tempo constante O(1) na m√©dia. A inser√ß√£o pode ser um pouco mais custosa que em uma lista, mas a diferen√ßa √© m√≠nima comparada √† vantagem na pesquisa.

Assim, para casos em que precisamos fazer muitas buscas, o HashSet √© muito mais eficiente do que o ArrayList.

2) A ideia √©: quanto mais gen√©rica a interface, mais flex√≠vel e desacoplado fica o c√≥digo, mas √†s vezes precisamos de comportamentos espec√≠ficos que s√≥ existem em interfaces mais especializadas. 

Se quisermos acessar elementos por posi√ß√£o, precisamos obrigatoriamente de um List, pois o m√©todo get(int index) n√£o existe em Collection

Resumindo pra resolu√ß√£o:

Use Collection quando qualquer cole√ß√£o serve.

Use List quando precisar de acesso posicional ou elementos ordenados por inser√ß√£o.

Use Set quando precisar de unicidade.

Use SortedSet/TreeSet quando precisar de unicidade e ordena√ß√£o natural.

===============================================================
Capitulo 17 Threads

17.4)
1) A execu√ß√£o muda sempre que rodamos pois n√£o sabemos como thread vai se comportar. 
Porque quem decide a ordem de execu√ß√£o das threads √© o escalonador da JVM + Sistema Operacional.

Ent√£o, cada vez que voc√™ roda, o SO pode dar mais tempo de CPU para t1 ou para t2, mudando a ordem da impress√£o.

√â justamente isso que o exerc√≠cio quer mostrar: concorr√™ncia = resultados n√£o determin√≠sticos (a ordem muda).

================================================================
                              Fim
Eu gostei bastante da did√°tica do livro, por mais que n√£o aborde as
novas funcionalidades como Stream e lambdas etc...
√â um livro muito bom pra entrada nos conhecimentos de java, possivelmente vou ler outros do caelum, com certeza contribuiu para meu desenvolvimento em java.

