Respostas dos exercícios de teoria do livro: Caelum
2.16 Por que Java foi escolhido em um projeto?
Geralmente java é escolhido pela portabilidade pois roda em qualquer sistema que tenha JVM, ou seja é ideal pra projetos que precisam rodar em Windows, Linux, mac ou até em servidores diferentes. 
Java também apresenta um diversidade grande de bibliotecas, pra web, banco de dados, segurança.
É bem rápido JIT compilation e tem uma boa gestão de memoria graças ao garbage collector.
Java é fortemente tipado o que ajuda a evitar erros.
Projetos grandes se beneficiam da estrutura de pacotes, modularidade e orientação a objetos.
Java possui diversos frameworks e ferramentas como Spring, Hibernate, Maven, Grandle, que facilitam o desenvolvimento...
Em resumo: O Java geralmente é escolhido quando se precisa de portabilidade, segurança, estabilidade e grande suporte da comunidade.

1) Um arquivo fonte java sempre deve terminar com .java Exemplo: MinhaClasse.java
Se a classe for public, o nome do arquivo deve ser igual ao nome da classe.

Compilação e execução:
Compile: javac OutraClasse.java
Isso gera OutraClasse.class(bytecode)
Execute: java OutraClasse (Não coloque .class)

3.3 Exercicios: (Realizados)

3.4 Convenções de código e código legí-
vel

Convenções de código, Por que existem? 
1. Padronização: Permitem que desenvolvedores escrevam códigos de forma consistente.
2. Facilitam a leitura e manutenção: Código padronizado é mais fácil de entender para outros desenvolvedores, mesmo que nunca tenham visto o projeto antes.
3. Reduz erros: Seguir padrões ajuda a evitar confusões e problemas, principalmente  em projetos grandes com várias pessoas

Por que são importantes?
Mantem a consistência e evita bugs e retrabalho.
IDE's, linters e frameworks funcionam melhor quando você segue convenções.
Facilita o onboarding de novos desenvolvedores.

(Linter): é uma ferramenta que analisa seu código para encontrar problemas de estilo, erros comuns ou más praticas. Exemplo Checkstyle é um linter que verifica se você está seguindo as convenções Java (nomes de métodos,identação,etc.).

(Onboarding): é o processo de integração de um novo funcionário ou desenvolvedor em uma equipe ou projeto. Inclui: aprender sobre o código, ferramentas, processos e  cultura da empresa.
Quanto mais legível e padronizado for o código, mais fácil e rápido é o onboarding.


As vantagens de escrever um código limpo e fácil de ler são a redução de erros, manutenção mais simples e menos necessidade de comentários.



3.12

1) do-while: quando queremos que a tarefa seja executada ao menos uma vez.
switch: é interessante quando temos uma cadeia de valores fixos, o que é mais interessante do que diversos else if.

2) Geralmente em um código bem limpo não teremos labeled loops. Mas ele é usado em for aninhados permitindo dar nome a um laço e usar break; ou continue  para interromper ou pular um laço externo.

3) Numero inteiro dividido por 0 -> Lança ArithmeticException que é um erro.
Numero ponto flutuante dividido por 0.0 -> Não lança erro, retorna infinity ou -infinity dependendo do sinal.

4) Casting entre tipos primitivos
Há uma conversão automática chamada widening de tipos menores para maiores
byte -> short -> int -> long -> float -> double
char -> int -> long -> float -> double

O casting explicido é necessário quando vai de um tipo maior para menor, para evitar perda de dados.


5) Incremento ou decremento e operações compostas.
Incremento: i++ (pós), ++i (pré) → soma 1 ao valor de i
Decremento: i-- ou --i → subtrai 1 do valor de i
Operadores compostos: i += x → i = i + x, i -= x → i = i - x

3.13/ 3.14 Exercícios de fixação de sintaxe (pulados).

4.11 Exercicios

1) Não pode começar com número (ex.: 1nome → errado)

Pode usar letras, números, $ e _, mas não espaços ou símbolos especiais.

Nomes sensíveis a maiúsculas/minúsculas (idade ≠ Idade)

Palavras reservadas do Java não podem ser usadas (class, int, for, etc.)

2) Variáveis e  métodos:  camelCase → começa com letra minúscula, depois maiúsculas em palavras internas (nomeFuncionario)

Classes:  PascalCase → todas palavras iniciam com maiúscula (Funcionario)

Constantes:  UPPER_CASE (PI)

Objetivo:  facilitar leitura, manutenção e entendimento do código entre programadores.

3) Não é obrigatória se não houver ambiguidade entre atributos e parâmetros.

4) É uma linguagem padrão de diagramas para modelar sistemas orientados a objetos.

Usos principais:

Representar classes, atributos, métodos, relacionamentos e fluxos do sistema.

Facilita comunicação, planejamento e documentação.

Ex.: Diagrama de classes UML de um Funcionario mostra atributos (nome, salario) e métodos (getNome(), setSalario()).

4.12 Exercícios: Orientação a Objetos (Realizados)

4.13 (Pendente)
Realizar exercício pra resolver a série de Fibonacci com recursividade.

4.14 (Pulados)


6.7 Um pouco mais...
1) Em algumas empresas, o UML é amplamente utilizado. Às vezes, o programador recebe o UML já pronto,
completo, e só deve preencher a implementação, devendo seguir à risca o UML. O que você acha dessa
prática? Quais as vantagens e desvantagens.
Entre as vantagens temos, a visualização, porque o UML ajuda a entender melhor o sistema antes de começar a codar, a padronização, pois o UML é uma linguagem padronizada para modelagem de sistemas, Documentação pois o uml funciona como documento do sistema, para o planejamento e design pois auxilia na identificação das classes, objetos e relacionamentos e reduz erros e retrabalho. E pode ser usado em sistemas pequenos e grandes e diferentes metodologias ágil,cascata, iterativa

Desvantagens: para sistemas pequenos o uml pode ser um exagero e consumir tempo.
Nem todo mundo entende todos os tipos de diagramas(caso de uso,classe,sequencia,etc..) sem treinamento.
Manutenção: podem ficar desatualizados se não forem mantidos juntos com o código.
Ferramentas: algumas ferramentas uml são pagas ou complicadas de utilizar.
Formalidade: focar demais em diagramas pode atrasar a entrega do software, principalmente em equipes ágeis.

2) Se uma classe só tem atributos e métodos estáticos, que conclusões podemos tirar? O que lhe parece um
método estático em casos como esses?
Não precisa de instancias ou seja como o Math em java, chamamos Math.sqrt(25), sem necessariamente criar um  Math m = new Math();
Geralmente essas classes possuem funções utilitárias ou constantes, como Converter.celsiusParaFahrenheit(), cálculos matemáticos, manipulações de String etc...
Estado global: ou seja eles são compartilhados com todos "Usuários" da classe, isso é como uma variável global, então precisamos ter cuidado com a concorrência ou efeitos colaterais.



3) No caso de atributos booleanos, pode-se usar no lugar do get o suxo is. Dessa maneira, caso tivéssemos
um atributo booleano ligado, em vez de getLigado poderíamos ter isLigado.

Sim, isso é uma convenção da nomenclatura em Java para atributos booleanos.


======================================================================

6.8 Exercicios 
1) Com modificador de acesso em private não é possivel acessar os atributos diretamente, ou seja ficam encapsulados.
6) Seria interresante ter os dois, tanto para listar todos os funcionarios como para listar um determinado funcionario.
7) Se dermos um new Empresa() sem passar argumento algum dá erro, pois é necessario que tenha o tamanho do array caso coloque.
8) o int x está fora do escopo de uma instancia static, metodos static não tem acesso a esses atributos da classe teste, a não ser se instanciar o objeto teste
com Teste teste = new Teste(); ai sim conseguiria.
9) Há dois passos para realização do singleton, 
1. tornar o construtor privado para que não tenha como criar um novo.
2. criar um método de criação estático que atue como um construtor. 
Internamente, esse método chama o construtor privado para criar um objeto e salvá-lo em um campo estático. 
Todas as chamadas subsequentes a esse método retornam o objeto armazenado em cache.
Como fazer? 
1. Adicione um campo estático privado à classe para armazenar a instância singleton.

2.Declare um método de criação estático público para obter a instância singleton.

3.Implemente a "inicialização preguiçosa" dentro do método estático. Ele deve criar um novo objeto na primeira chamada e colocá-lo no campo estático. O método deve sempre retornar essa instância em todas as chamadas subsequentes.

4.Torne o construtor da classe privado. O método estático da classe ainda poderá chamar o construtor, mas não os outros objetos.

5.Revise o código do cliente e substitua todas as chamadas diretas ao construtor do singleton por chamadas ao seu método de criação estático.

E para carater de aprendizado singleton 

package refactoring_guru.singleton.example.non_thread_safe;

Um breve exemplo:

public final class Singleton {
    private static Singleton instance;
    public String value;

    private Singleton(String value) {
        // The following code emulates slow initialization.
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        this.value = value;
    }

    public static Singleton getInstance(String value) {
        if (instance == null) {
            instance = new Singleton(value);
        }
        return instance;
    }
}

package refactoring_guru.singleton.example.non_thread_safe;

public class DemoSingleThread {
    public static void main(String[] args) {
        System.out.println("If you see the same value, then singleton was reused (yay!)" + "\n" +
                "If you see different values, then 2 singletons were created (booo!!)" + "\n\n" +
                "RESULT:" + "\n");
        Singleton singleton = Singleton.getInstance("FOO");
        Singleton anotherSingleton = Singleton.getInstance("BAR");
        System.out.println(singleton.value);
        System.out.println(anotherSingleton.value);
    }
}

//Informação retiradas do refactoring.guru

==============================================================

7.6
1) Se não houvesse herança em Java, como você poderia reaproveitar o código de outra classe? 
R: Acredito que no famoso crtl + c / ctrl + v/ Ou composição ou delegação.

Composição: em vez de herdar de uma classe, você cria um atributo do tipo dessa classe e utiliza seus métodos.


2) Uma discussão muito atual é sobre o abuso no uso da herança. Algumas pessoas usam herança apenas
para reaproveitar o código, quando poderiam ter feito uma composição. Procure sobre herança versus
composição.  

Herança vs Composição (discussão atual):

Herança (is-a): usada quando a classe é um tipo da outra. Ex: Cachorro extends Animal.

Vantagens: facilita polimorfismo, reaproveita código.

Desvantagens: pode gerar acoplamento rígido (mudanças na classe mãe afetam as filhas).

Composição (has-a): usada quando a classe possui um objeto de outra classe. Ex: Carro tem um Motor.

Vantagens: mais flexível, permite trocar implementações em tempo de execução, reduz acoplamento.

Desvantagens: às vezes gera mais "trabalho" na hora de repassar métodos.

Use herança quando há uma clara relação "é um" (ex: Gato é um Animal).

Prefira composição quando for apenas "tem um" (ex: Carro tem um Motor).


3) É o uso de super() dentro dos construtores, que chama o construtor da classe mãe.

====

7.7 Exercícios Herança e Poliformismo

4) Cada uma imprime um valor diferente, pois seus metodos foram reescritos.

5) Compila, pois o JVM decide em tempo de execução qual metodo  chamar, com poliformismo dinamico. É util para generalizar o codigo  sem  precisar criar uma logica separada para cada subtipo

9) Não

10) Foi feito mas com arrayList

7.8) Usar protected em atributos afrouxa o encapsulamento → não é a melhor prática.

O ideal é manter os atributos sempre private.

Para as filhas trabalharem com eles, você pode:

Criar getters/setters protected.

Criar métodos específicos protected (ex: saca(), deposita()) em vez de dar acesso livre.

Usar construtores protegidos para inicializar o atributo.

Assim, a herança funciona sem expor desnecessariamente os dados.

Resumindo: encapsulamento continua com private, e as filhas acessam via métodos controlados.

=======================================================
Capitulo 8 - Aborda mais sobre o eclipse IDE então foi pulado.
=======================================================

9.6 Classes Abstratas

1) Sim, pois não queremos que uma conta seja só uma Conta e sim uma ContaCorrente ou ContaPoupança, então interface é uma boa.

2) A vantagem é generalizar e trabalhar com poliformismo dinamico.

3) A classe poupança é obrigada a implementar pois na interface não existe implementação

5) existe sim, mas a classe ContaCorrente também teria que ser uma interface.

6) O metodo atualiza na classe é pra firmar um contrato com quem extends essa abstract e ser obrigado, se apagarmos da classe Conta não vamos poder referenciar.

7) ok

=====================================================
Os capitulos anteriores foram sobre classe abstrata e interface: Fazendo um comparativo direto entre os dois temos as seguintes caracteristicas. 
Uma classe abstrata é usada quando existe algo em comum entre as classes, funcionando de forma parecida com a herança. Ela não pode ser instanciada, pode ter atributos, métodos concretos e também métodos abstratos. Normalmente é usada quando se quer compartilhar estado e parte da implementação entre subclasses. Só permite herança simples.

Já a interface representa um contrato: qualquer classe que a implemente deve obrigatoriamente fornecer a implementação dos métodos definidos. Diferente da classe abstrata, quem implementa a interface não precisa ter nada em comum além da capacidade de realizar as ações especificadas. Interfaces não possuem atributos de instância, apenas constantes, e permitem múltiplas implementações, ou seja, uma classe pode implementar várias interfaces ao mesmo tempo.

Usa classe abstrata quando as classes têm características em comum (atributos e parte da lógica compartilhada) e tu quer reaproveitar código.

Usa interface quando tu precisa só de um contrato de comportamento, sem herança de atributos ou implementação, e quando uma classe pode ter várias "capacidades" diferentes ao mesmo tempo.

Exercícios dos capitulos anteriores feitos.

=======================================================
Cap 11. Exceções e controle.
Exercícios resolvidos.

11.12) Quando a JVM (Java Virtual Machine) não consegue mais alocar memória para novos objetos, ela lança um java.lang.OutOfMemoryError.

“Heap space” é a área de memória onde os objetos do Java são alocados.

Isso normalmente acontece quando:

Criamos muitos objetos e não liberamos referência a eles (vazamento de memória / memory leak).

Alocamos arrays enormes ou coleções gigantes.

💡 Observação: a JVM tenta primeiro liberar memória via garbage collector (GC), mas se mesmo assim não houver espaço suficiente, o OutOfMemoryError ocorre.


=========================================================

Usar catch(Exception e) ou throws Exception é má prática, porque generaliza os erros. Quem recebe a exceção não sabe exatamente qual tipo ocorreu e não consegue tratá-la corretamente.

Se queremos tratar várias exceções de forma igual (ex.: IOException e SQLException), não é recomendável usar catch(Exception e), pois isso também pegaria outras exceções inesperadas.

A solução correta é usar multi-catch (Java 7+), permitindo tratar múltiplas exceções específicas em um único bloco, sem duplicar código:

try {
    // código que pode lançar IOException ou SQLException
} catch (IOException | SQLException e) {
    // tratamento comum para essas exceções
}


✅ Vantagem: mantém o tratamento específico das exceções sem generalizar para todas e evita repetição de código.


====================================================================

Capítulo 14 - O pacote java.lang
Exercícios Realizados.

15)  (opcional) Pesquise a classe StringBuilder (ou StringBuer no Java 1.4). Ela é mutável. Por que usá-la
em vez da String? Quando usá-la? 

String é imutável, então cada concatenação cria um novo objeto na memória. 

StringBuilder é mutável, permitindo modificar a mesma sequência de caracteres sem criar novos objetos.

Use String para poucas concatenações e StringBuilder quando for fazer muitas alterações ou dentro de loops, pois é mais rápido e eficiente.

=====================================================================

Capitulo 15 java.io

Unicode e character encoding?


=====================================================================

Capitulo 16 Collections

compareTo(Object). Este método deve retornar zero, se o objeto comparado for igual a este objeto, um número negativo, se este objeto for menor que o objeto dado, e um número positivo, se este objeto for maior que o objeto dado.

Exercícios:

1) No ArrayList, a operação contains() percorre a lista elemento por elemento até encontrar (ou não) o valor, ou seja, tem complexidade O(n). Isso torna a busca lenta quando o número de elementos cresce, mesmo que a inserção seja rápida.

Já no HashSet, os elementos são armazenados em uma tabela hash, o que faz com que a busca (contains()) seja feita em tempo constante O(1) na média. A inserção pode ser um pouco mais custosa que em uma lista, mas a diferença é mínima comparada à vantagem na pesquisa.

Assim, para casos em que precisamos fazer muitas buscas, o HashSet é muito mais eficiente do que o ArrayList.

2) A ideia é: quanto mais genérica a interface, mais flexível e desacoplado fica o código, mas às vezes precisamos de comportamentos específicos que só existem em interfaces mais especializadas. 

Se quisermos acessar elementos por posição, precisamos obrigatoriamente de um List, pois o método get(int index) não existe em Collection

Resumindo pra resolução:

Use Collection quando qualquer coleção serve.

Use List quando precisar de acesso posicional ou elementos ordenados por inserção.

Use Set quando precisar de unicidade.

Use SortedSet/TreeSet quando precisar de unicidade e ordenação natural.

===============================================================
Capitulo 17 Threads

17.4)
1) A execução muda sempre que rodamos pois não sabemos como thread vai se comportar. 
Porque quem decide a ordem de execução das threads é o escalonador da JVM + Sistema Operacional.

Então, cada vez que você roda, o SO pode dar mais tempo de CPU para t1 ou para t2, mudando a ordem da impressão.

É justamente isso que o exercício quer mostrar: concorrência = resultados não determinísticos (a ordem muda).

================================================================
                              Fim
Eu gostei bastante da didática do livro, por mais que não aborde as
novas funcionalidades como Stream e lambdas etc...
É um livro muito bom pra entrada nos conhecimentos de java, possivelmente vou ler outros do caelum, com certeza contribuiu para meu desenvolvimento em java.

